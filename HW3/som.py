# -*- coding: utf-8 -*-
"""SOM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rloWZn6SoiEtoOqdvCQLVMJStE0WKu6m
"""

import matplotlib
import numpy as np
import sys
import  matplotlib.pyplot as plt
from sklearn.metrics.pairwise import euclidean_distances
import os
import pandas as pd
from skimage import io
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn import metrics


def create_data_set(x_crop=150, y_crop=150, train_size=0.9):
    images_path = [os.path.join("yalefaces", item) for item in os.listdir("yalefaces")]
    image_data = []
    image_labels = []

    for i, im_path in enumerate(images_path):
        im = io.imread(im_path, as_gray=True)
        image_data.append(np.array(im, dtype='uint8').ravel())

        label = os.path.split(im_path)[1].split(".")[1]
        image_labels.append(label)

    X_ = np.array(image_data).astype('float32')
    enc = LabelEncoder()
    y_ = enc.fit_transform(np.array(image_labels))
    print(enc.classes_)
    X_train, X_test, y_train, y_test = train_test_split(X_, y_, train_size=train_size, random_state=22)

    return X_train, X_test, y_train, y_test

class SOM:
    def __init__(self, map_size, lr=1):
        """

        :param map_size: [map_w, map_h, f=16]
        """
        self.map = np.random.random(size=map_size)
        self.lr0 = lr
        self.lr = self.lr0

        self.R0 = map_size[0]/8
        self.R = self.R0


    def train(self, X, y, T=1000, error_threshold=10**-20):
        #self.map = self.map + np.tile(X[1], [self.map.shape[0], self.map.shape[1], 1])
        Js = []
        for t in range(T):
            self.labels = []
            print(t)
            prev_map = self.map.copy()
            #shuffle_ind = np.random.randint(low=0, high=len(X), size=len(X))
            shuffle_ind = np.arange(len(X))
            np.random.shuffle(shuffle_ind)
            for i in range(len(X)):
                x = X[shuffle_ind[i], :]
                winner = self.find_winner(x)  #winner = [55, 23]
                NS = self.get_NS(winner)
                self.update_weights(x, NS, len(X))
                self.labels.append(winner[0]*self.map.shape[0]+winner[1])
            self.lr = self.lr0 * np.exp(-t/T) 
            self.R = self.R0 * np.exp(-t/T)
            
            J = np.linalg.norm(prev_map - self.map)
            Js.append(J)
            purity = self.purity_score(y)
            if t % 1 == 0:
                print("Iteration: %d, LR: %f, R:%f, J: %f, purity: %f" %(t,self.lr,self.R, Js[-1], purity))

            if J < error_threshold:
                print("MIN_CHANGE")
                break

        return Js

    def visualize(self, X, y):
        self.scores = np.zeros(shape=(self.map.shape[0],self.map.shape[0], len(np.unique(y))))
        for i in range(len(X)):
            x = X[i, :]
            winner = self.find_winner(x)
            iw,jw = winner[0], winner[1]
            self.scores[iw,jw,y[i]] += 1
        self.scores_sum = np.sum(self.scores,axis=-1)
        self.scores_max = np.argmax(self.scores, axis=-1)
        self.scores_max[np.where(self.scores_sum==0)] = -1
        print(self.scores_max)
        #from_list = matplotlib.colors.LinearSegmentedColormap.from_list
        #cm = from_list('Set15', plt.cm.Set1(range(0, len(np.unique(y)+1))), len(np.unique(y)+1))
        #plt.cm.register_cmap(None, cm)
        #plt.set_cmap(cm)
        fig, ax = plt.subplots()
        ax.matshow(self.scores_max)
        for (i, j), z in np.ndenumerate(self.scores_max):
          ax.text(j, i, z, ha='center', va='center')
        plt.show()
    

    def find_winner(self, x):
        dists = euclidean_distances([x], self.map.reshape(self.map.shape[0]*self.map.shape[1],self.map.shape[2])).T.ravel()

        '''
        rep_x = np.tile(x, [self.map.shape[0], self.map.shape[1], 1])
        dists = np.sum((self.map - rep_x)**2, axis=2)
        '''
        winner = np.unravel_index(np.argmin(dists,axis=None), (self.map.shape[0],self.map.shape[1]))
        return winner

    def get_NS(self, winner):
        #net_mask = np.zeros(shape=[self.map.shape[0], self.map.shape[1]])
        iw, jw = winner[0], winner[1]
        x, y = np.mgrid[0:self.map.shape[0]:1, 0:self.map.shape[1]:1]
        pos = np.dstack((x, y)).reshape((self.map.shape[0]*self.map.shape[1],2))
        dist = euclidean_distances(np.asarray([[iw,jw]]),pos).T.ravel()
        net_mask = np.exp(-(dist ** 2) / (2 * (self.R ** 2)))
        '''
        for w in range(self.map.shape[0]):
            for h in range(self.map.shape[1]):
                net_mask[w, h] = np.exp(-((iw - w) ** 2 + (jw - h) ** 2) / (2 * (self.R ** 2)))
        '''
        return net_mask.reshape((self.map.shape[0],self.map.shape[1]))

    def update_weights(self, x, n_strength, X_len):
        #NS = np.tile(n_strength, [self.map.shape[2], 1, 1]).transpose()
        #rep_x = np.tile(x, [self.map.shape[0], self.map.shape[1], 1])
        Delta = - self.map + x 
        self.map = self.map + (self.lr) * np.multiply(Delta.T, n_strength.T).T

    def extract_feature(self, X):
        f_X = []
        for x in X:
          rep_x = np.tile(x, [self.map.shape[0], self.map.shape[1], 1])
          f_X.append(np.sum((self.map - rep_x) ** 2, axis=2).ravel())
        return 1/(1+np.array(f_X))

    def purity_score(self, y):
      contingency_matrix = metrics.cluster.contingency_matrix(y, self.labels)
      return np.sum(np.amax(contingency_matrix, axis=0)) / np.sum(contingency_matrix)

    def u_matrix(self,X):
      self.u_matrix = np.zeros(shape=(self.map.shape[0],self.map.shape[1]))
      for x in range(self.map.shape[0]):
        for y in range(self.map.shape[1]):
          neighs = []
          if x - 1 >= 0:
            neighs.append(self.map[x-1,y]) 
          if x + 1 < self.map.shape[0]:
            neighs.append(self.map[x+1,y])
          if y - 1 >= 0:
            neighs.append(self.map[x,y-1]) 
          if y + 1 < self.map.shape[1]:
            neighs.append(self.map[x,y+1]) 

          neighs = np.array(neighs)
          self.u_matrix[x,y] = np.sum(euclidean_distances([self.map[x,y]],neighs).ravel())

      scores = np.zeros(shape=(self.map.shape[0],self.map.shape[0]))
      for i in range(len(X)):
            x = X[i, :]
            winner = self.find_winner(x)
            iw,jw = winner[0], winner[1]
            scores[iw,jw] += 1

      fig, ax = plt.subplots()
      ax.matshow(self.u_matrix,cmap='gray')
      for (i, j), z in np.ndenumerate(scores):
        ax.text(j, i, z, ha='center', va='center', c='blue')
      plt.show()

if __name__ == "__main__":
    X_train, X_test, y_train, y_test = create_data_set()
    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)
    som_net = SOM(map_size=[14,14,X_train.shape[1]])
    Js = som_net.train(X_train, y_train, T=20)
    plt.plot(Js)
    plt.show()
    som_net.visualize(X_train,y_train)
    som_net.u_matrix(X_train)

    X_train = som_net.extract_feature(X_train)
    X_test = som_net.extract_feature(X_test)

    X_train = pd.DataFrame(X_train)
    X_train.to_csv('drive/MyDrive/dataset/HW3/X_train.csv', index=False, header=False)
    X_test = pd.DataFrame(X_test)
    X_test.to_csv('drive/MyDrive/dataset/HW3/X_test.csv', index=False, header=False)
    y_train = pd.DataFrame(y_train)
    y_train.to_csv('drive/MyDrive/dataset/HW3/y_train.csv', index=False, header=False)
    y_test = pd.DataFrame(y_test)
    y_test.to_csv('drive/MyDrive/dataset/HW3/y_test.csv', index=False, header=False)

